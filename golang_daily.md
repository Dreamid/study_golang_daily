# init 函数什么时候执行？
- import –> const –> var –> init() –> main()
- init() 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。
- 每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。
- 同一个包，甚至是同一个源文件可以有多个 init() 函数。
- init() 函数没有入参和返回值，不能被其他函数调用。
- 同一个包内多个 init() 函数的执行顺序不作保证。


# struct{}占多少内存？有什么作用？
占用0内存，一般用于channel信号传输。

# new()与make()的区别？
1. 适用类型不同，make() 只适用于 slice，channel，map ，new()适用于值类型，如数组，结构体等。
2. 结果不同：new(T) 会为T类型的新值分配已置零的内存空间，并返回内存地址（指针），即类型为*T的值。（返回一个指针，该指针指向新分配的，类型为T的零值）；make(T,args)返回初始化之后的T类型的值，这个值并不是T类型的零值，也不是指针*T，而是经过初始化之后的T的引用。 

# 新类型和别名 （新类型和int之间需要强制转换，别名与int之间不需要强制转换）
type IntAlias = int  别名
type NewInt 新类型

var a1 IntAlias
var a2 NewInt
----------------------------
## 新类型和别名的区别1：使用type查看结果不同，别名显示的是原类型，新类型显示其本身。
## 区别2：编译完成后，别名不存在，新类型存在。
fmt.Print(type(a1))-----int ----IntAlias类型只会在代码中存在，编译完成后，不会有 IntAlias 类型。
fmt.Print(type(a2))-----NewInt 新类型，编译完成后，依旧存在该类型。
## 区别3：非本地类型不能定义方法：
给别名类型定义新方法，编译会报错，提示：can't defin new methods on non-local type XXX 及：不能在一个非本地的类型XXX上定义新方法。
解决办法：1. 将别名改为新类型 2. 将别名定义放在XX类型原包中。




